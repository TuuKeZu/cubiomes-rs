//! Minecraft biome data generator
//!
//! This module is used to generate biomes from minecraft seeds
//! using the generator from the cubiomes library

use std::{
    alloc::{alloc, dealloc, Layout},
    mem::transmute,
};

use bitflags::bitflags;
use thiserror::Error;

use crate::{enums, Range};
use cubiomes_sys::{getMinCacheSize, num_traits::FromPrimitive};

#[derive(Error, Debug, PartialEq, Eq)]
pub enum GeneratorError {
    #[error("Biome id {0} is out of range and is not a valid biomeid")]
    BiomeIDOutOfRange(i32),
    #[error(
        "Function getBiomeAt failed with error code -1, did you forgot to initialize the seed?"
    )]
    GetBiomeAtFailure,
    #[error("Function genBiomes failed with error code {0}")]
    GenBiomeToCacheFailure(i32),
    #[error("Index out of bounds")]
    IndexOutOfBound,
}

bitflags! {
    /// Flags for the cubiomes generator
    pub struct GeneratorFlags: u32 {
        const LargeBiomes = 0x1;
        const NoBetaOcean = 0x2;
        const ForceOceanVariants = 0x4;
        //the source may set any bits
        const _ = !0;
    }
}

/// Valid scales for getting a single points biome
pub enum Scale {
    Block = 1,
    Biome = 4,
}

/// The cubioems generator
///
/// This is the struct which holds a cubiomes generator
/// and is used for most actions with the generator
///
/// A new instance of the generator can be created with [`Generator::new()`]
///
/// Biomes can be generated either with [`self.get_biome_at()`] for single points
/// in conjuntion with a [`Cache`] generated by [`self.new_cache()`]
pub struct Generator {
    generator: *mut cubiomes_sys::Generator,
}

impl Drop for Generator {
    fn drop(&mut self) {
        // Safety:
        // The memory is safe to deallocate as its been allocated in new
        // and the pointer to it is dropped, so it is never referred to again
        unsafe {
            dealloc(self.generator as *mut u8, Layout::new::<Generator>());
        }
    }
}

/// A cache for generating and holding a chunk of biome data
///
/// The cache is usually generated with [`Generator::new_cache()`]
/// and holds a vector filled with biome data.
///
pub struct Cache<'a> {
    cache: Vec<i32>,
    range: cubiomes_sys::Range,
    generator: &'a Generator,
}

impl Generator {
    /// Initializes a new generator for the given minecraft version and flags
    /// with a seed and dimension applied
    ///
    /// This function initializes a new cubiomes generator and then gives
    /// it a seed.
    ///
    /// # Examples
    ///
    /// ```
    /// use cubiomes::generator::{Generator, GeneratorFlags};
    /// use cubiomes::enums::{MCVersion, Dimension};
    ///
    /// let seed: i64 = -4804349813814383506;
    /// let mc_version = MCVersion::MC_1_21_WD;
    ///
    /// let generator = Generator::new(mc_version, seed, Dimension::DIM_OVERWORLD, GeneratorFlags::empty());
    ///
    /// // Use the generator for something
    /// ```
    pub fn new(
        mc_version: enums::MCVersion,
        seed: i64,
        dimension: enums::Dimension,
        flags: GeneratorFlags,
    ) -> Self {
        // SAFETY:
        // the generator is immediatly given a seed
        unsafe {
            let mut generator = Generator::new_without_seed(mc_version, flags);
            generator.apply_seed(dimension, seed);

            generator
        }
    }

    /// Initializes a new generator for the given minecraft version and flags
    ///
    /// This function initializes a new cubiomes generator for the specified
    /// version of minecraft with the specified flags. To use the generator it
    /// must be given a seed with [`self.apply_seed()`]
    ///
    /// # Safety
    /// Before using any generation functions one must use [`self.apply_seed()`]
    /// to give the generator a seed, otherwise the generation will fail.
    ///
    /// # Examples
    /// ```
    ///    
    /// use cubiomes::generator::Generator;
    /// use cubiomes::enums::MCVersion;
    /// use cubiomes::generator::GeneratorFlags;
    ///
    /// // Version of minecraft to use with the generator
    /// let mc_version = MCVersion::MC_1_21_WD;
    /// let generator;
    /// unsafe{
    ///     generator = Generator::new_without_seed(mc_version, GeneratorFlags::empty());
    /// }
    /// ```
    pub unsafe fn new_without_seed(version: enums::MCVersion, flags: GeneratorFlags) -> Self {
        // SAFETY:
        // The function is safe since the generated pointer
        // points to memory that can fit a Generator and
        // the pointer is stored as a pointer
        unsafe {
            let generator =
                alloc(Layout::new::<cubiomes_sys::Generator>()) as *mut cubiomes_sys::Generator;

            cubiomes_sys::setupGenerator(generator, version as i32, flags.bits());
            Self { generator }
        }
    }

    /// Sets the seed for the generator
    ///
    /// Sets a new seed to the generator. This can either be used for
    /// initialization if the generator was generated with [`self.new_without_seed()`]
    /// or changing the seed of the generator
    pub fn apply_seed(&mut self, dimension: enums::Dimension, seed: i64) {
        // SAFETY:
        // As the generator is correctly initialized and its fields are private
        // the applySeed function is only given valid instances of generator
        unsafe {
            cubiomes_sys::applySeed(
                self.generator,
                dimension as i32,
                transmute::<i64, u64>(seed),
            );
        }
    }

    /// Gets the biome at the specified coordinates and scale
    ///
    /// Returns a biomeid or then an error.
    /// For the most consitent results querying surface biomes
    /// you should use 256 as the y value (minecraft build limit)
    pub fn get_biome_at(
        &self,
        scale: Scale,
        x: i32,
        y: i32,
        z: i32,
    ) -> Result<enums::BiomeID, GeneratorError> {
        // SAFETY:
        // As the generator is correctly initialized and its fields are private
        // the applySeed function is only given valid instances of generator.
        //
        // The scale enum guarantees that getBiomeAt is only given a scale of 1 or 4
        // As specified in its documentation
        unsafe {
            match cubiomes_sys::getBiomeAt(self.generator, scale as i32, x, y, z) {
                -1 => Err(GeneratorError::GetBiomeAtFailure),
                n => FromPrimitive::from_i32(n).ok_or(GeneratorError::BiomeIDOutOfRange(n)),
            }
        }
    }

    fn get_min_cache_size_from_range(&self, range: Range) -> usize {
        self.get_min_cache_size(range.scale, range.sx, range.sy, range.sz)
    }

    /// Gets the minimum cache size for a specific sized range
    ///
    /// y can be either 0 or 1 for a plane
    ///
    /// # Panics
    /// Panics if scale, size_x, or size_z are 0 or less and if size_y is less than 0
    fn get_min_cache_size(&self, scale: i32, size_x: i32, size_y: i32, size_z: i32) -> usize {
        assert!(scale > 0);
        assert!(size_x > 0);
        assert!(size_y >= 0);
        assert!(size_z > 0);

        // SAFETY:
        // The function is sound, because we disallow the attempts go generate a cache_size
        // with negative numbers.
        //
        // The requirement for this is checked from the source code and not from documentation
        unsafe { getMinCacheSize(self.generator, scale, size_x, size_y, size_z) }
    }

    /// Fills the provided cache from the generator
    ///
    /// # Safety
    /// The caller must guarantee, that the cache is able to contain the generated data.
    /// The best way to guarantee this, is to use a cache generated from this generator
    /// using the [Self::new_cache()] function.
    unsafe fn generate_biomes_to_cache(&self, cache: &mut Cache) -> Result<(), GeneratorError> {
        let result_num =
            cubiomes_sys::genBiomes(self.generator, cache.cache.as_mut_ptr(), cache.range);

        // If error is returned from genbiomes, dont resize the vec as it may contain garbage data
        if result_num != 0 {
            return Err(GeneratorError::GenBiomeToCacheFailure(result_num));
        }

        //We set the caches lenght to that which the cubiome docs state it should be
        cache
            .cache
            .set_len(self.get_min_cache_size_from_range(cache.range));

        Ok(())
    }
}

impl<'a> Generator {
    /// Generates a new cache for the given generator
    ///
    /// This function creates a new [`Cache`] against this version of the generator
    pub fn new_cache(&'a self, range: cubiomes_sys::Range) -> Cache<'a> {
        let cache_size = self.get_min_cache_size_from_range(range);

        let cache = Vec::with_capacity(cache_size);

        Cache {
            cache,
            range,
            generator: self,
        }
    }
}

impl Cache<'_> {
    /// Fills the cache so it can be read
    pub fn fill_cache(&mut self) -> Result<(), GeneratorError> {
        // Safety:
        // As the cache holds a reference to the generator, the generator
        // could not have been modified after the vec was allocated so the
        // vec inside this cache holds enough space for the generator
        unsafe { self.generator.generate_biomes_to_cache(self) }
    }

    /// Gets a reference to the internal representation of the cache.
    ///
    /// The cache is a linear array which can be accessed at the following
    /// index: ``y * self.range.sx * self.range.sz + z * self.range.sx + x``
    /// If the cache is a plane use y=0 for the index
    ///
    /// # Examples
    ///
    /// ```
    /// use cubiomes::generator::Cache;
    /// use cubiomes::Range;
    ///
    /// use cubiomes::generator::{Generator, GeneratorFlags};
    /// use cubiomes::enums::{MCVersion, Dimension, BiomeID};
    ///
    /// let mut generator = Generator::new(
    ///     MCVersion::MC_1_21_WD,
    ///     -380434930381432806,
    ///     Dimension::DIM_OVERWORLD,
    ///     GeneratorFlags::empty()
    /// );
    ///
    /// let mut cache = generator.new_cache(Range {
    ///     scale: 1,
    ///     x: 512,
    ///     z: -512,
    ///     sx: 64,
    ///     sz: 64,
    ///     y: 100,
    ///     sy: 0,
    /// });
    ///
    /// cache.fill_cache().expect("failed to fill cache");
    ///
    /// // Read the cache at z=32, x=5
    ///
    /// assert_eq!(cache.get_cache()[(13 + cache.get_range().sx + 5) as usize], BiomeID::plains as i32);
    ///
    pub fn get_cache(&self) -> &Vec<i32> {
        &self.cache
    }

    /// Gets a read-only reference to the range used by this cache
    ///
    /// Gets the range this cache was generated with. Useful for
    /// if you want to read from the caches.
    ///
    /// See example from [`self.get_cache()`] for example usage
    pub fn get_range(&self) -> &Range {
        &self.range
    }

    /// This function gets a biome at the specified point in the cache
    ///
    /// The specified point is relative to the left upper corner of
    /// the caches range.
    ///
    /// # Panics
    /// panics with outofbounds if cache has not been generated
    ///
    /// # Warning
    /// As the cache is represented by an array, there are no checks to
    /// stop you from getting things outside the bounds of the cache
    ///
    /// This will not cause ub, but the generated biome will not represent
    /// the location which you are looking for
    pub fn get_biome_at(&self, x: i32, y: i32, z: i32) -> Result<enums::BiomeID, GeneratorError> {
        let raw_biomeid = *self
            .cache
            .get((y * self.range.sx * self.range.sz + z * self.range.sx + x) as usize)
            .ok_or(GeneratorError::IndexOutOfBound)?;

        enums::BiomeID::from_i32(raw_biomeid).ok_or(GeneratorError::BiomeIDOutOfRange(raw_biomeid))
    }

    /// Moves the cache without reallocating the space
    ///
    /// Moves the cache to the new position without allocation.
    /// Can be used to generate multiple positions without reallocation.
    ///
    /// # Panics
    /// panics if the new cache cannot hold the required space.
    pub fn move_cache(&mut self, x: i32, y: i32, z: i32) {
        let new_range = Range {
            x,
            y,
            z,
            ..self.range
        };

        // We make sure the cache can still hold the required items
        assert!(self.generator.get_min_cache_size_from_range(new_range) >= self.cache.capacity());

        self.range = new_range
    }
}
